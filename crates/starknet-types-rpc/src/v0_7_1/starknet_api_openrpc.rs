//
// This file was automatically generated by openrpc-gen.
//
// Do not edit it manually and instead edit either the source OpenRPC document,
// the configuration file, or open an issue or pull request on the openrpc-gen
// GitHub repository.
//
//     https://github.com/nils-mathieu/openrpc-gen
//

use super::{BlockId, BroadcastedDeclareTxn, BroadcastedDeployAccountTxn, BroadcastedInvokeTxn};
use crate::custom_serde::NumAsHex;
use alloc::string::String;
use alloc::vec::Vec;
use core::marker::PhantomData;
use serde::ser::SerializeMap;
use serde::{Deserialize, Serialize};

pub type Address<F> = F;

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct TransactionAndReceipt<F> {
    pub receipt: TxnReceipt<F>,
    pub transaction: Txn<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct TxnWithHash<F> {
    #[serde(flatten)]
    pub transaction: Txn<F>,
    pub transaction_hash: TxnHash<F>,
}

pub type BlockHash<F> = F;

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct BlockHeader<F> {
    pub block_hash: BlockHash<F>,
    /// The block number (its height)
    pub block_number: BlockNumber,
    /// specifies whether the data of this block is published via blob data or calldata
    pub l1_da_mode: L1DaMode,
    /// The price of l1 data gas in the block
    pub l1_data_gas_price: ResourcePrice<F>,
    /// The price of l1 gas in the block
    pub l1_gas_price: ResourcePrice<F>,
    /// The new global state root
    pub new_root: F,
    /// The hash of this block's parent
    pub parent_hash: BlockHash<F>,
    /// The StarkNet identity of the sequencer submitting this block
    pub sequencer_address: F,
    /// Semver of the current Starknet protocol
    pub starknet_version: String,
    /// The time in which the block was created, encoded in Unix time
    pub timestamp: u64,
}

/// The block's number (its height)
pub type BlockNumber = u64;

/// The status of the block
#[derive(Serialize, Deserialize, Copy, PartialEq, Eq, Hash, Clone, Debug)]
pub enum BlockStatus {
    #[serde(rename = "ACCEPTED_ON_L1")]
    AcceptedOnL1,
    #[serde(rename = "ACCEPTED_ON_L2")]
    AcceptedOnL2,
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "REJECTED")]
    Rejected,
}

/// A tag specifying a dynamic reference to a block
#[derive(Serialize, Deserialize, Copy, PartialEq, Eq, Hash, Clone, Debug)]
pub enum BlockTag {
    #[serde(rename = "latest")]
    Latest,
    #[serde(rename = "pending")]
    Pending,
}

/// The block object
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct BlockWithReceipts<F> {
    /// The transactions in this block
    pub transactions: Vec<TransactionAndReceipt<F>>,
    pub status: BlockStatus,
    #[serde(flatten)]
    pub block_header: BlockHeader<F>,
}

/// The block object
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct BlockWithTxs<F> {
    /// The transactions in this block
    pub transactions: Vec<TxnWithHash<F>>,
    pub status: BlockStatus,
    #[serde(flatten)]
    pub block_header: BlockHeader<F>,
}

/// The block object
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct BlockWithTxHashes<F> {
    /// The hashes of the transactions included in this block
    pub transactions: Vec<TxnHash<F>>,
    pub status: BlockStatus,
    #[serde(flatten)]
    pub block_header: BlockHeader<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct BroadcastedDeclareTxnV1<F: Default> {
    /// The class to be declared
    pub contract_class: DeprecatedContractClass<F>,
    /// The maximal fee that can be charged for including the transaction
    pub max_fee: F,
    pub nonce: F,
    /// The address of the account contract sending the declaration transaction
    pub sender_address: Address<F>,
    pub signature: Signature<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct BroadcastedDeclareTxnV2<F> {
    /// The hash of the Cairo assembly resulting from the Sierra compilation
    pub compiled_class_hash: F,
    /// The class to be declared
    pub contract_class: ContractClass<F>,
    /// The maximal fee that can be charged for including the transaction
    pub max_fee: F,
    pub nonce: F,
    /// The address of the account contract sending the declaration transaction
    pub sender_address: Address<F>,
    pub signature: Signature<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum BroadcastedTxn<F: Default> {
    #[serde(rename = "INVOKE")]
    Invoke(BroadcastedInvokeTxn<F>),
    #[serde(rename = "DECLARE")]
    Declare(BroadcastedDeclareTxn<F>),
    #[serde(rename = "DEPLOY_ACCOUNT")]
    DeployAccount(BroadcastedDeployAccountTxn<F>),
}

/// StarkNet chain id, given in hex representation.
pub type ChainId = u64;

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct CommonReceiptProperties<F> {
    /// The fee that was charged by the sequencer
    pub actual_fee: FeePayment<F>,
    /// The events emitted as part of this transaction
    pub events: Vec<Event<F>>,
    /// The resources consumed by the transaction
    pub execution_resources: ExecutionResources,
    /// finality status of the tx
    pub finality_status: TxnFinalityStatus,
    pub messages_sent: Vec<MsgToL1<F>>,
    /// The hash identifying the transaction
    pub transaction_hash: TxnHash<F>,
    #[serde(flatten)]
    pub anon: Anonymous,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Anonymous {
    /// Common properties for a transaction receipt that was executed successfully
    Successful(SuccessfulCommonReceiptProperties),
    /// Common properties for a transaction receipt that was reverted
    Reverted(RevertedCommonReceiptProperties),
}

/// Common properties for a transaction receipt that was executed successfully
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct SuccessfulCommonReceiptProperties {
    /// The execution status of the transaction
    pub execution_status: String, /* SUCCEEDED */
}

/// Common properties for a transaction receipt that was reverted
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct RevertedCommonReceiptProperties {
    /// The execution status of the transaction
    pub execution_status: String, /* REVERTED */
    /// the revert reason for the failed execution
    pub revert_reason: String,
}

/// The resources consumed by the VM
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct ComputationResources {
    /// the number of BITWISE builtin instances
    #[serde(default)]
    pub bitwise_builtin_applications: Option<u64>,
    /// the number of EC_OP builtin instances
    #[serde(default)]
    pub ec_op_builtin_applications: Option<u64>,
    /// the number of ECDSA builtin instances
    #[serde(default)]
    pub ecdsa_builtin_applications: Option<u64>,
    /// The number of KECCAK builtin instances
    #[serde(default)]
    pub keccak_builtin_applications: Option<u64>,
    /// The number of unused memory cells (each cell is roughly equivalent to a step)
    #[serde(default)]
    pub memory_holes: Option<u64>,
    /// The number of Pedersen builtin instances
    #[serde(default)]
    pub pedersen_builtin_applications: Option<u64>,
    /// The number of Poseidon builtin instances
    #[serde(default)]
    pub poseidon_builtin_applications: Option<u64>,
    /// The number of RANGE_CHECK builtin instances
    #[serde(default)]
    pub range_check_builtin_applications: Option<u64>,
    /// The number of accesses to the segment arena
    #[serde(default)]
    pub segment_arena_builtin: Option<u64>,
    /// The number of Cairo steps used
    pub steps: u64,
}

pub type ContractAbi = Vec<ContractAbiEntry>;

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContractAbiEntry {
    Function(FunctionAbiEntry),
    Event(EventAbiEntry),
    Struct(StructAbiEntry),
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct ContractClass<F> {
    /// The class ABI, as supplied by the user declaring the class
    #[serde(default)]
    pub abi: Option<String>,
    /// The version of the contract class object. Currently, the Starknet OS supports version 0.1.0
    pub contract_class_version: String,
    pub entry_points_by_type: EntryPointsByType<F>,
    /// The list of Sierra instructions of which the program consists
    pub sierra_program: Vec<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct EntryPointsByType<F> {
    #[serde(rename = "CONSTRUCTOR")]
    pub constructor: Vec<SierraEntryPoint<F>>,
    #[serde(rename = "EXTERNAL")]
    pub external: Vec<SierraEntryPoint<F>>,
    #[serde(rename = "L1_HANDLER")]
    pub l1_handler: Vec<SierraEntryPoint<F>>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct ContractStorageDiffItem<F: Default> {
    /// The contract address for which the storage changed
    pub address: F,
    /// The changes in the storage of the contract
    pub storage_entries: Vec<KeyValuePair<F>>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct KeyValuePair<F> {
    /// The key of the changed value
    #[serde(default)]
    pub key: Option<F>,
    /// The new value applied to the given address
    #[serde(default)]
    pub value: Option<F>,
}

/// Specifies a storage domain in Starknet. Each domain has different gurantess regarding availability
#[derive(Serialize, Deserialize, Copy, PartialEq, Eq, Hash, Clone, Debug)]
pub enum DaMode {
    L1,
    L2,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(tag = "version")]
pub enum DeclareTxn<F> {
    #[serde(rename = "0x0")]
    V0(DeclareTxnV0<F>),
    #[serde(rename = "0x1")]
    V1(DeclareTxnV1<F>),
    #[serde(rename = "0x2")]
    V2(DeclareTxnV2<F>),
    #[serde(rename = "0x3")]
    V3(DeclareTxnV3<F>),
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeclareTxnReceipt<F> {
    #[serde(flatten)]
    pub common_receipt_properties: CommonReceiptProperties<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeclareTxnV0<F> {
    /// The hash of the declared class
    pub class_hash: F,
    /// The maximal fee that can be charged for including the transaction
    pub max_fee: F,
    /// The address of the account contract sending the declaration transaction
    pub sender_address: Address<F>,
    pub signature: Signature<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeclareTxnV1<F> {
    /// The hash of the declared class
    pub class_hash: F,
    /// The maximal fee that can be charged for including the transaction
    pub max_fee: F,
    pub nonce: F,
    /// The address of the account contract sending the declaration transaction
    pub sender_address: Address<F>,
    pub signature: Signature<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeclareTxnV2<F> {
    /// The hash of the declared class
    pub class_hash: F,
    /// The hash of the Cairo assembly resulting from the Sierra compilation
    pub compiled_class_hash: F,
    /// The maximal fee that can be charged for including the transaction
    pub max_fee: F,
    pub nonce: F,
    /// The address of the account contract sending the declaration transaction
    pub sender_address: Address<F>,
    pub signature: Signature<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeclareTxnV3<F> {
    /// data needed to deploy the account contract from which this tx will be initiated
    pub account_deployment_data: Vec<F>,
    /// The hash of the declared class
    pub class_hash: F,
    /// The hash of the Cairo assembly resulting from the Sierra compilation
    pub compiled_class_hash: F,
    /// The storage domain of the account's balance from which fee will be charged
    pub fee_data_availability_mode: DaMode,
    pub nonce: F,
    /// The storage domain of the account's nonce (an account has a nonce per DA mode)
    pub nonce_data_availability_mode: DaMode,
    /// data needed to allow the paymaster to pay for the transaction in native tokens
    pub paymaster_data: Vec<F>,
    /// resource bounds for the transaction execution
    pub resource_bounds: ResourceBoundsMapping,
    /// The address of the account contract sending the declaration transaction
    pub sender_address: Address<F>,
    pub signature: Signature<F>,
    /// the tip for the transaction
    pub tip: U64,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeployedContractItem<F> {
    /// The address of the contract
    pub address: F,
    /// The hash of the contract code
    pub class_hash: F,
}

/// deploys a new account contract
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(tag = "version")]
pub enum DeployAccountTxn<F> {
    #[serde(rename = "0x1")]
    V1(DeployAccountTxnV1<F>),
    #[serde(rename = "0x3")]
    V3(DeployAccountTxnV3<F>),
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeployAccountTxnReceipt<F> {
    #[serde(flatten)]
    pub common_receipt_properties: CommonReceiptProperties<F>,
    /// The address of the deployed contract
    pub contract_address: F,
}

/// Deploys an account contract, charges fee from the pre-funded account addresses
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeployAccountTxnV1<F> {
    /// The hash of the deployed contract's class
    pub class_hash: F,
    /// The parameters passed to the constructor
    pub constructor_calldata: Vec<F>,
    /// The salt for the address of the deployed contract
    pub contract_address_salt: F,
    /// The maximal fee that can be charged for including the transaction
    pub max_fee: F,
    pub nonce: F,
    pub signature: Signature<F>,
}

/// Deploys an account contract, charges fee from the pre-funded account addresses
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeployAccountTxnV3<F> {
    /// The hash of the deployed contract's class
    pub class_hash: F,
    /// The parameters passed to the constructor
    pub constructor_calldata: Vec<F>,
    /// The salt for the address of the deployed contract
    pub contract_address_salt: F,
    /// The storage domain of the account's balance from which fee will be charged
    pub fee_data_availability_mode: DaMode,
    pub nonce: F,
    /// The storage domain of the account's nonce (an account has a nonce per DA mode)
    pub nonce_data_availability_mode: DaMode,
    /// data needed to allow the paymaster to pay for the transaction in native tokens
    pub paymaster_data: Vec<F>,
    /// resource bounds for the transaction execution
    pub resource_bounds: ResourceBoundsMapping,
    pub signature: Signature<F>,
    /// the tip for the transaction
    pub tip: U64,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeployTxn<F> {
    /// The hash of the deployed contract's class
    pub class_hash: F,
    /// The parameters passed to the constructor
    pub constructor_calldata: Vec<F>,
    /// The salt for the address of the deployed contract
    pub contract_address_salt: F,
    /// Version of the transaction scheme
    pub version: F,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeployTxnReceipt<F> {
    #[serde(flatten)]
    pub common_receipt_properties: CommonReceiptProperties<F>,
    /// The address of the deployed contract
    pub contract_address: F,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeprecatedCairoEntryPoint<F> {
    /// The offset of the entry point in the program
    #[serde(with = "NumAsHex")]
    pub offset: u64,
    /// A unique identifier of the entry point (function) in the program
    pub selector: F,
}

/// The definition of a StarkNet contract class
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeprecatedContractClass<F: Default> {
    #[serde(default)]
    pub abi: Option<ContractAbi>,
    pub entry_points_by_type: DeprecatedEntryPointsByType<F>,
    /// A base64 representation of the compressed program code
    pub program: String,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeprecatedEntryPointsByType<F> {
    #[serde(default)]
    #[serde(rename = "CONSTRUCTOR")]
    pub constructor: Option<Vec<DeprecatedCairoEntryPoint<F>>>,
    #[serde(default)]
    #[serde(rename = "EXTERNAL")]
    pub external: Option<Vec<DeprecatedCairoEntryPoint<F>>>,
    #[serde(default)]
    #[serde(rename = "L1_HANDLER")]
    pub l1_handler: Option<Vec<DeprecatedCairoEntryPoint<F>>>,
}

/// Event information decorated with metadata on where it was emitted / An event emitted as a result of transaction execution
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct EmittedEvent<F> {
    /// The event information
    #[serde(flatten)]
    pub event: Event<F>,
    /// The hash of the block in which the event was emitted
    #[serde(default)]
    pub block_hash: Option<BlockHash<F>>,
    /// The number of the block in which the event was emitted
    #[serde(default)]
    pub block_number: Option<BlockNumber>,
    /// The transaction that emitted the event
    pub transaction_hash: TxnHash<F>,
}

/// an ethereum address represented as 40 hex digits
pub type EthAddress = String;

/// A StarkNet event
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct Event<F> {
    pub from_address: Address<F>,
    pub data: Vec<F>,
    pub keys: Vec<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct EventsChunk<F: Default> {
    /// Use this token in a subsequent query to obtain the next page. Should not appear if there are no more pages.
    #[serde(default)]
    pub continuation_token: Option<String>,
    pub events: Vec<EmittedEvent<F>>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct EventAbiEntry {
    pub data: Vec<TypedParameter>,
    pub keys: Vec<TypedParameter>,
    /// The event name
    pub name: String,
    #[serde(rename = "type")]
    pub ty: EventAbiType,
}

pub type EventAbiType = String;

/// the resources consumed by the transaction, includes both computation and data
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct ExecutionResources {
    /// the number of BITWISE builtin instances
    #[serde(default)]
    pub bitwise_builtin_applications: Option<u64>,
    /// the number of EC_OP builtin instances
    #[serde(default)]
    pub ec_op_builtin_applications: Option<u64>,
    /// the number of ECDSA builtin instances
    #[serde(default)]
    pub ecdsa_builtin_applications: Option<u64>,
    /// The number of KECCAK builtin instances
    #[serde(default)]
    pub keccak_builtin_applications: Option<u64>,
    /// The number of unused memory cells (each cell is roughly equivalent to a step)
    #[serde(default)]
    pub memory_holes: Option<u64>,
    /// The number of Pedersen builtin instances
    #[serde(default)]
    pub pedersen_builtin_applications: Option<u64>,
    /// The number of Poseidon builtin instances
    #[serde(default)]
    pub poseidon_builtin_applications: Option<u64>,
    /// The number of RANGE_CHECK builtin instances
    #[serde(default)]
    pub range_check_builtin_applications: Option<u64>,
    /// The number of accesses to the segment arena
    #[serde(default)]
    pub segment_arena_builtin: Option<u64>,
    /// The number of Cairo steps used
    pub steps: u64,
    pub data_availability: DataAvailability,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct DataAvailability {
    /// the data gas consumed by this transaction's data, 0 if it uses gas for DA
    pub l1_data_gas: u64,
    /// the gas consumed by this transaction's data, 0 if it uses data gas for DA
    pub l1_gas: u64,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct FeeEstimate<F> {
    /// The Ethereum data gas consumption of the transaction
    pub data_gas_consumed: F,
    /// The data gas price (in wei or fri, depending on the tx version) that was used in the cost estimation
    pub data_gas_price: F,
    /// The Ethereum gas consumption of the transaction
    pub gas_consumed: F,
    /// The gas price (in wei or fri, depending on the tx version) that was used in the cost estimation
    pub gas_price: F,
    /// The estimated fee for the transaction (in wei or fri, depending on the tx version), equals to gas_consumed*gas_price + data_gas_consumed*data_gas_price
    pub overall_fee: F,
    /// units in which the fee is given
    pub unit: PriceUnit,
}

/// fee payment info as it appears in receipts
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct FeePayment<F> {
    /// amount paid
    pub amount: F,
    /// units in which the fee is given
    pub unit: PriceUnit,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct FunctionAbiEntry {
    pub inputs: Vec<TypedParameter>,
    /// The function name
    pub name: String,
    pub outputs: Vec<TypedParameter>,
    #[serde(default)]
    #[serde(rename = "stateMutability")]
    pub state_mutability: Option<FunctionStateMutability>,
    #[serde(rename = "type")]
    pub ty: FunctionAbiType,
}

#[derive(Serialize, Deserialize, Copy, PartialEq, Eq, Hash, Clone, Debug)]
pub enum FunctionAbiType {
    #[serde(rename = "constructor")]
    Constructor,
    #[serde(rename = "function")]
    Function,
    #[serde(rename = "l1_handler")]
    L1Handler,
}

/// Function call information
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct FunctionCall<F> {
    /// The parameters passed to the function
    pub calldata: Vec<F>,
    pub contract_address: Address<F>,
    pub entry_point_selector: F,
}

pub type FunctionStateMutability = String;

/// Initiate a transaction from an account
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(tag = "version")]
pub enum InvokeTxn<F> {
    #[serde(rename = "0x0")]
    V0(InvokeTxnV0<F>),
    #[serde(rename = "0x1")]
    V1(InvokeTxnV1<F>),
    #[serde(rename = "0x3")]
    V3(InvokeTxnV3<F>),
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct InvokeTxnReceipt<F> {
    #[serde(flatten)]
    pub common_receipt_properties: CommonReceiptProperties<F>,
}

/// invokes a specific function in the desired contract (not necessarily an account)
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct InvokeTxnV0<F> {
    /// The parameters passed to the function
    pub calldata: Vec<F>,
    pub contract_address: Address<F>,
    pub entry_point_selector: F,
    /// The maximal fee that can be charged for including the transaction
    pub max_fee: F,
    pub signature: Signature<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct InvokeTxnV1<F> {
    /// The data expected by the account's `execute` function (in most usecases, this includes the called contract address and a function selector)
    pub calldata: Vec<F>,
    /// The maximal fee that can be charged for including the transaction
    pub max_fee: F,
    pub nonce: F,
    pub sender_address: Address<F>,
    pub signature: Signature<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct InvokeTxnV3<F> {
    /// data needed to deploy the account contract from which this tx will be initiated
    pub account_deployment_data: Vec<F>,
    /// The data expected by the account's `execute` function (in most usecases, this includes the called contract address and a function selector)
    pub calldata: Vec<F>,
    /// The storage domain of the account's balance from which fee will be charged
    pub fee_data_availability_mode: DaMode,
    pub nonce: F,
    /// The storage domain of the account's nonce (an account has a nonce per DA mode)
    pub nonce_data_availability_mode: DaMode,
    /// data needed to allow the paymaster to pay for the transaction in native tokens
    pub paymaster_data: Vec<F>,
    /// resource bounds for the transaction execution
    pub resource_bounds: ResourceBoundsMapping,
    pub sender_address: Address<F>,
    pub signature: Signature<F>,
    /// the tip for the transaction
    pub tip: U64,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct L1HandlerTxn<F> {
    /// The L1->L2 message nonce field of the SN Core L1 contract at the time the transaction was sent
    #[serde(with = "NumAsHex")]
    pub nonce: u64,
    /// Version of the transaction scheme
    pub version: String, /* 0x0 */
    #[serde(flatten)]
    pub function_call: FunctionCall<F>,
}

/// receipt for l1 handler transaction
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct L1HandlerTxnReceipt<F> {
    /// The message hash as it appears on the L1 core contract
    #[serde(with = "NumAsHex")]
    pub message_hash: u64,
    #[serde(flatten)]
    pub common_receipt_properties: CommonReceiptProperties<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct MsgFromL1<F> {
    /// The selector of the l1_handler in invoke in the target contract
    pub entry_point_selector: F,
    /// The address of the L1 contract sending the message
    pub from_address: EthAddress,
    /// The payload of the message
    pub payload: Vec<F>,
    /// The target L2 address the message is sent to
    pub to_address: Address<F>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct MsgToL1<F> {
    /// The address of the L2 contract sending the message
    pub from_address: F,
    /// The payload of the message
    pub payload: Vec<F>,
    /// The target L1 address the message is sent to
    pub to_address: F,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct PendingBlockHeader<F> {
    /// specifies whether the data of this block is published via blob data or calldata
    pub l1_da_mode: L1DaMode,
    /// The price of l1 data gas in the block
    pub l1_data_gas_price: ResourcePrice<F>,
    /// The price of l1 gas in the block
    pub l1_gas_price: ResourcePrice<F>,
    /// The hash of this block's parent
    pub parent_hash: BlockHash<F>,
    /// The StarkNet identity of the sequencer submitting this block
    pub sequencer_address: F,
    /// Semver of the current Starknet protocol
    pub starknet_version: String,
    /// The time in which the block was created, encoded in Unix time
    pub timestamp: u64,
}

/// specifies whether the data of this block is published via blob data or calldata
#[derive(Serialize, Deserialize, Copy, PartialEq, Eq, Hash, Clone, Debug)]
pub enum L1DaMode {
    #[serde(rename = "BLOB")]
    Blob,
    #[serde(rename = "CALLDATA")]
    Calldata,
}

/// The dynamic block being constructed by the sequencer. Note that this object will be deprecated upon decentralization.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct PendingBlockWithReceipts<F> {
    /// The transactions in this block
    pub transactions: Vec<TransactionAndReceipt<F>>,
    #[serde(flatten)]
    pub pending_block_header: PendingBlockHeader<F>,
}

/// The dynamic block being constructed by the sequencer. Note that this object will be deprecated upon decentralization.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct PendingBlockWithTxs<F> {
    /// The transactions in this block
    pub transactions: Vec<TxnWithHash<F>>,
    #[serde(flatten)]
    pub pending_block_header: PendingBlockHeader<F>,
}

/// The dynamic block being constructed by the sequencer. Note that this object will be deprecated upon decentralization.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct PendingBlockWithTxHashes<F> {
    /// The hashes of the transactions included in this block
    pub transactions: Vec<TxnHash<F>>,
    #[serde(flatten)]
    pub pending_block_header: PendingBlockHeader<F>,
}

/// Pending state update
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct PendingStateUpdate<F: Default> {
    /// The previous global state root
    pub old_root: F,
    pub state_diff: StateDiff<F>,
}

#[derive(Serialize, Deserialize, Copy, PartialEq, Eq, Hash, Clone, Debug)]
pub enum PriceUnit {
    #[serde(rename = "FRI")]
    Fri,
    #[serde(rename = "WEI")]
    Wei,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct ResourceBounds {
    /// the max amount of the resource that can be used in the tx
    pub max_amount: U64,
    /// the max price per unit of this resource for this tx
    pub max_price_per_unit: U128,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct ResourceBoundsMapping {
    /// The max amount and max price per unit of L1 gas used in this tx
    pub l1_gas: ResourceBounds,
    /// The max amount and max price per unit of L2 gas used in this tx
    pub l2_gas: ResourceBounds,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct ResourcePrice<F> {
    /// the price of one unit of the given resource, denominated in fri (10^-18 strk)
    pub price_in_fri: F,
    /// the price of one unit of the given resource, denominated in wei
    pub price_in_wei: F,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct SierraEntryPoint<F> {
    /// The index of the function in the program
    pub function_idx: u64,
    /// A unique identifier of the entry point (function) in the program
    pub selector: F,
}

/// A transaction signature
pub type Signature<F> = Vec<F>;

/// Flags that indicate how to simulate a given transaction. By default, the sequencer behavior is replicated locally
pub type SimulationFlagForEstimateFee = String;

/// The change in state applied in this block, given as a mapping of addresses to the new values and/or new contracts
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct StateDiff<F: Default> {
    pub declared_classes: Vec<NewClasses<F>>,
    pub deployed_contracts: Vec<DeployedContractItem<F>>,
    pub deprecated_declared_classes: Vec<F>,
    pub nonces: Vec<NonceUpdate<F>>,
    pub replaced_classes: Vec<ReplacedClass<F>>,
    pub storage_diffs: Vec<ContractStorageDiffItem<F>>,
}

/// The declared class hash and compiled class hash
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct NewClasses<F> {
    /// The hash of the declared class
    #[serde(default)]
    pub class_hash: Option<F>,
    /// The Cairo assembly hash corresponding to the declared class
    #[serde(default)]
    pub compiled_class_hash: Option<F>,
}

/// The updated nonce per contract address
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct NonceUpdate<F> {
    /// The address of the contract
    #[serde(default)]
    pub contract_address: Option<Address<F>>,
    /// The nonce for the given address at the end of the block
    #[serde(default)]
    pub nonce: Option<F>,
}

/// The list of contracts whose class was replaced
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct ReplacedClass<F> {
    /// The new class hash
    #[serde(default)]
    pub class_hash: Option<F>,
    /// The address of the contract whose class was replaced
    #[serde(default)]
    pub contract_address: Option<Address<F>>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct StateUpdate<F: Default> {
    pub block_hash: BlockHash<F>,
    /// The new global state root
    pub new_root: F,
    /// The previous global state root
    pub old_root: F,
    pub state_diff: StateDiff<F>,
}

/// A storage key. Represented as up to 62 hex digits, 3 bits, and 5 leading zeroes.
pub type StorageKey = String;

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct StructAbiEntry {
    pub members: Vec<StructMember>,
    /// The struct name
    pub name: String,
    pub size: u64,
    #[serde(rename = "type")]
    pub ty: StructAbiType,
}

pub type StructAbiType = String;

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct StructMember {
    #[serde(flatten)]
    pub typed_parameter: TypedParameter,
    /// offset of this property within the struct
    #[serde(default)]
    pub offset: Option<u64>,
}

/// An object describing the node synchronization status
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct SyncStatus<F> {
    /// The hash of the current block being synchronized
    pub current_block_hash: BlockHash<F>,
    /// The number (height) of the current block being synchronized
    pub current_block_num: BlockNumber,
    /// The hash of the estimated highest block to be synchronized
    pub highest_block_hash: BlockHash<F>,
    /// The number (height) of the estimated highest block to be synchronized
    pub highest_block_num: BlockNumber,
    /// The hash of the block from which the sync started
    pub starting_block_hash: BlockHash<F>,
    /// The number (height) of the block from which the sync started
    pub starting_block_num: BlockNumber,
}

/// The transaction schema, as it appears inside a block
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Txn<F> {
    #[serde(rename = "INVOKE")]
    Invoke(InvokeTxn<F>),
    #[serde(rename = "L1_HANDLER")]
    L1Handler(L1HandlerTxn<F>),
    #[serde(rename = "DECLARE")]
    Declare(DeclareTxn<F>),
    #[serde(rename = "DEPLOY")]
    Deploy(DeployTxn<F>),
    #[serde(rename = "DEPLOY_ACCOUNT")]
    DeployAccount(DeployAccountTxn<F>),
}

/// The execution status of the transaction
#[derive(Serialize, Deserialize, Copy, PartialEq, Eq, Hash, Clone, Debug)]
pub enum TxnExecutionStatus {
    #[serde(rename = "REVERTED")]
    Reverted,
    #[serde(rename = "SUCCEEDED")]
    Succeeded,
}

/// The finality status of the transaction
#[derive(Serialize, Deserialize, Copy, PartialEq, Eq, Hash, Clone, Debug)]
pub enum TxnFinalityStatus {
    #[serde(rename = "ACCEPTED_ON_L1")]
    L1,
    #[serde(rename = "ACCEPTED_ON_L2")]
    L2,
}

/// The transaction hash, as assigned in StarkNet
// pub type TxnHash<F: Serialize + for<'de> Deserialize<'de>> = F;
pub type TxnHash<F> = F;

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum TxnReceipt<F> {
    #[serde(rename = "INVOKE")]
    Invoke(InvokeTxnReceipt<F>),
    #[serde(rename = "L1_HANDLER")]
    L1Handler(L1HandlerTxnReceipt<F>),
    #[serde(rename = "DECLARE")]
    Declare(DeclareTxnReceipt<F>),
    #[serde(rename = "DEPLOY")]
    Deploy(DeployTxnReceipt<F>),
    #[serde(rename = "DEPLOY_ACCOUNT")]
    DeployAccount(DeployAccountTxnReceipt<F>),
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct TxnReceiptWithBlockInfo<F> {
    #[serde(flatten)]
    pub transaction_receipt: TxnReceipt<F>,
    /// If this field is missing, it means the receipt belongs to the pending block
    #[serde(default)]
    pub block_hash: Option<BlockHash<F>>,
    /// If this field is missing, it means the receipt belongs to the pending block
    #[serde(default)]
    pub block_number: Option<BlockNumber>,
}

/// The finality status of the transaction, including the case the txn is still in the mempool or failed validation during the block construction phase
#[derive(Serialize, Deserialize, Copy, PartialEq, Eq, Hash, Clone, Debug)]
pub enum TxnStatus {
    #[serde(rename = "ACCEPTED_ON_L1")]
    AcceptedOnL1,
    #[serde(rename = "ACCEPTED_ON_L2")]
    AcceptedOnL2,
    #[serde(rename = "RECEIVED")]
    Received,
    #[serde(rename = "REJECTED")]
    Rejected,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct TypedParameter {
    /// The parameter's name
    pub name: String,
    /// The parameter's type
    #[serde(rename = "type")]
    pub ty: String,
}

/// 64 bit integers, represented by hex string of length at most 32
pub type U128 = String;

/// 64 bit integers, represented by hex string of length at most 16
pub type U64 = String;

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct BlockHashAndNumber<F> {
    pub block_hash: BlockHash<F>,
    pub block_number: BlockNumber,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StarknetGetBlockWithTxsAndReceiptsResult<F> {
    Block(BlockWithReceipts<F>),
    Pending(PendingBlockWithReceipts<F>),
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MaybePendingBlockWithTxHashes<F> {
    Block(BlockWithTxHashes<F>),
    Pending(PendingBlockWithTxHashes<F>),
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MaybePendingBlockWithTxs<F> {
    Block(BlockWithTxs<F>),
    Pending(PendingBlockWithTxs<F>),
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MaybeDeprecatedContractClass<F: Default> {
    Deprecated(DeprecatedContractClass<F>),
    ContractClass(ContractClass<F>),
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct EventFilterWithPageRequest<F: Copy> {
    #[serde(default)]
    pub address: Option<Address<F>>,
    #[serde(default)]
    pub from_block: Option<BlockId<F>>,
    /// The values used to filter the events
    #[serde(default)]
    pub keys: Option<Vec<Vec<F>>>,
    #[serde(default)]
    pub to_block: Option<BlockId<F>>,
    pub chunk_size: u64,
    /// The token returned from the previous query. If no token is provided the first page is returned.
    #[serde(default)]
    pub continuation_token: Option<String>,
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MaybePendingStateUpdate<F: Default> {
    Block(StateUpdate<F>),
    Pending(PendingStateUpdate<F>),
}

#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct TxnFinalityAndExecutionStatus {
    #[serde(default)]
    pub execution_status: Option<TxnExecutionStatus>,
    pub finality_status: TxnStatus,
}

/// Parameters of the `starknet_specVersion` method.
#[derive(Debug, Clone)]
pub struct SpecVersionParams {}

impl Serialize for SpecVersionParams {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.end()
    }
}

impl<'de> Deserialize<'de> for SpecVersionParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor;

        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpecVersionParams;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_specVersion`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        1,
                        &"expected 0 parameters",
                    ));
                }

                Ok(SpecVersionParams {})
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper {}

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(SpecVersionParams {})
            }
        }

        deserializer.deserialize_any(Visitor)
    }
}

/// Parameters of the `starknet_getBlockWithTxHashes` method.
#[derive(Debug, Clone)]
pub struct GetBlockWithTxHashesParams<F> {
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
}

impl<F: Copy + Serialize> Serialize for GetBlockWithTxHashesParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.end()
    }
}

impl<'de, F: Serialize + Deserialize<'de>> Deserialize<'de> for GetBlockWithTxHashesParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetBlockWithTxHashesParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getBlockWithTxHashes`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 1 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        2,
                        &"expected 1 parameters",
                    ));
                }

                Ok(GetBlockWithTxHashesParams { block_id })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    block_id: BlockId<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetBlockWithTxHashesParams {
                    block_id: helper.block_id,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getBlockWithTxs` method.
#[derive(Debug, Clone)]
pub struct GetBlockWithTxsParams<F> {
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
}

impl<F: Copy + Serialize> Serialize for GetBlockWithTxsParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de> for GetBlockWithTxsParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetBlockWithTxsParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getBlockWithTxs`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 1 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        2,
                        &"expected 1 parameters",
                    ));
                }

                Ok(GetBlockWithTxsParams { block_id })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    block_id: BlockId<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetBlockWithTxsParams {
                    block_id: helper.block_id,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getBlockWithReceipts` method.
#[derive(Debug, Clone)]
pub struct GetBlockWithReceiptsParams<F> {
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
}

impl<F: Copy + Serialize> Serialize for GetBlockWithReceiptsParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.end()
    }
}

impl<'de, F: Copy + Deserialize<'de>> Deserialize<'de> for GetBlockWithReceiptsParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetBlockWithReceiptsParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getBlockWithReceipts`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 1 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        2,
                        &"expected 1 parameters",
                    ));
                }

                Ok(GetBlockWithReceiptsParams { block_id })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    block_id: BlockId<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetBlockWithReceiptsParams {
                    block_id: helper.block_id,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getStateUpdate` method.
#[derive(Debug, Clone)]
pub struct GetStateUpdateParams<F> {
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
}

impl<F: Copy + Serialize> Serialize for GetStateUpdateParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de> for GetStateUpdateParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetStateUpdateParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getStateUpdate`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 1 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        2,
                        &"expected 1 parameters",
                    ));
                }

                Ok(GetStateUpdateParams { block_id })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    block_id: BlockId<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetStateUpdateParams {
                    block_id: helper.block_id,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getStorageAt` method.
#[derive(Debug, Clone)]
pub struct GetStorageAtParams<F> {
    /// The address of the contract to read from
    pub contract_address: Address<F>,
    /// The key to the storage value for the given contract
    pub key: StorageKey,
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
}

impl<F: Copy + Serialize> Serialize for GetStorageAtParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("contract_address", &self.contract_address)?;
        map.serialize_entry("key", &self.key)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de> for GetStorageAtParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetStorageAtParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getStorageAt`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let contract_address: Address<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 3 parameters"))?;
                let key: StorageKey = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(2, &"expected 3 parameters"))?;
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(3, &"expected 3 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        4,
                        &"expected 3 parameters",
                    ));
                }

                Ok(GetStorageAtParams {
                    contract_address,
                    key,
                    block_id,
                })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    contract_address: Address<F>,
                    key: StorageKey,
                    block_id: BlockId<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetStorageAtParams {
                    contract_address: helper.contract_address,
                    key: helper.key,
                    block_id: helper.block_id,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getTransactionStatus` method.
#[derive(Debug, Clone)]
pub struct GetTransactionStatusParams<F> {
    /// The hash of the requested transaction
    pub transaction_hash: TxnHash<F>,
}

impl<F: Serialize> Serialize for GetTransactionStatusParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("transaction_hash", &self.transaction_hash)?;
        map.end()
    }
}

impl<'de, F: Deserialize<'de>> Deserialize<'de> for GetTransactionStatusParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetTransactionStatusParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getTransactionStatus`")
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    transaction_hash: TxnHash<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetTransactionStatusParams {
                    transaction_hash: helper.transaction_hash,
                })
            }
        }

        deserializer.deserialize_map(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getTransactionByHash` method.
#[derive(Debug, Clone)]
pub struct GetTransactionByHashParams<F> {
    /// The hash of the requested transaction
    pub transaction_hash: TxnHash<F>,
}

impl<F: Serialize> Serialize for GetTransactionByHashParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("transaction_hash", &self.transaction_hash)?;
        map.end()
    }
}

impl<'de, F: Deserialize<'de>> Deserialize<'de> for GetTransactionByHashParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetTransactionByHashParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getTransactionByHash`")
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    transaction_hash: TxnHash<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetTransactionByHashParams {
                    transaction_hash: helper.transaction_hash,
                })
            }
        }

        deserializer.deserialize_map(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getTransactionByBlockIdAndIndex` method.
#[derive(Debug, Clone)]
pub struct GetTransactionByBlockIdAndIndexParams<F> {
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
    /// The index in the block to search for the transaction
    pub index: u64,
}

impl<F: Copy + Serialize> Serialize for GetTransactionByBlockIdAndIndexParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.serialize_entry("index", &self.index)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de>
    for GetTransactionByBlockIdAndIndexParams<F>
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetTransactionByBlockIdAndIndexParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(
                    f,
                    "the parameters for `starknet_getTransactionByBlockIdAndIndex`"
                )
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 2 parameters"))?;
                let index: u64 = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(2, &"expected 2 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        3,
                        &"expected 2 parameters",
                    ));
                }

                Ok(GetTransactionByBlockIdAndIndexParams { block_id, index })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    block_id: BlockId<F>,
                    index: u64,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetTransactionByBlockIdAndIndexParams {
                    block_id: helper.block_id,
                    index: helper.index,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getTransactionReceipt` method.
#[derive(Debug, Clone)]
pub struct GetTransactionReceiptParams<F> {
    /// The hash of the requested transaction
    pub transaction_hash: TxnHash<F>,
}

impl<F: Serialize> Serialize for GetTransactionReceiptParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("transaction_hash", &self.transaction_hash)?;
        map.end()
    }
}

impl<'de, F: Deserialize<'de>> Deserialize<'de> for GetTransactionReceiptParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetTransactionReceiptParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getTransactionReceipt`")
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    transaction_hash: TxnHash<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetTransactionReceiptParams {
                    transaction_hash: helper.transaction_hash,
                })
            }
        }

        deserializer.deserialize_map(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getClass` method.
#[derive(Debug, Clone)]
pub struct GetClassParams<F> {
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
    /// The hash of the requested contract class
    pub class_hash: F,
}

impl<F: Copy + Serialize> Serialize for GetClassParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.serialize_entry("class_hash", &self.class_hash)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de> for GetClassParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetClassParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getClass`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 2 parameters"))?;
                let class_hash: F = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(2, &"expected 2 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        3,
                        &"expected 2 parameters",
                    ));
                }

                Ok(GetClassParams {
                    block_id,
                    class_hash,
                })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    block_id: BlockId<F>,
                    class_hash: F,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetClassParams {
                    block_id: helper.block_id,
                    class_hash: helper.class_hash,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getClassHashAt` method.
#[derive(Debug, Clone)]
pub struct GetClassHashAtParams<F> {
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
    /// The address of the contract whose class hash will be returned
    pub contract_address: Address<F>,
}

impl<F: Copy + Serialize> Serialize for GetClassHashAtParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.serialize_entry("contract_address", &self.contract_address)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de> for GetClassHashAtParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetClassHashAtParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getClassHashAt`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 2 parameters"))?;
                let contract_address: Address<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(2, &"expected 2 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        3,
                        &"expected 2 parameters",
                    ));
                }

                Ok(GetClassHashAtParams {
                    block_id,
                    contract_address,
                })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    block_id: BlockId<F>,
                    contract_address: Address<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetClassHashAtParams {
                    block_id: helper.block_id,
                    contract_address: helper.contract_address,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getClassAt` method.
#[derive(Debug, Clone)]
pub struct GetClassAtParams<F> {
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
    /// The address of the contract whose class definition will be returned
    pub contract_address: Address<F>,
}

impl<F: Copy + Serialize> Serialize for GetClassAtParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.serialize_entry("contract_address", &self.contract_address)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de> for GetClassAtParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetClassAtParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getClassAt`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 2 parameters"))?;
                let contract_address: Address<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(2, &"expected 2 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        3,
                        &"expected 2 parameters",
                    ));
                }

                Ok(GetClassAtParams {
                    block_id,
                    contract_address,
                })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    block_id: BlockId<F>,
                    contract_address: Address<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetClassAtParams {
                    block_id: helper.block_id,
                    contract_address: helper.contract_address,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getBlockTransactionCount` method.
#[derive(Debug, Clone)]
pub struct GetBlockTransactionCountParams<F> {
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
}

impl<F: Copy + Serialize> Serialize for GetBlockTransactionCountParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de>
    for GetBlockTransactionCountParams<F>
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetBlockTransactionCountParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getBlockTransactionCount`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 1 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        2,
                        &"expected 1 parameters",
                    ));
                }

                Ok(GetBlockTransactionCountParams { block_id })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    block_id: BlockId<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetBlockTransactionCountParams {
                    block_id: helper.block_id,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_call` method.
#[derive(Debug, Clone)]
pub struct CallParams<F> {
    /// The details of the function call
    pub request: FunctionCall<F>,
    /// The hash of the requested block, or number (height) of the requested block, or a block tag, for the block referencing the state or call the transaction on.
    pub block_id: BlockId<F>,
}

impl<F: Copy + Serialize> Serialize for CallParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("request", &self.request)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de> for CallParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = CallParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_call`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let request: FunctionCall<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 2 parameters"))?;
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(2, &"expected 2 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        3,
                        &"expected 2 parameters",
                    ));
                }

                Ok(CallParams { request, block_id })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    request: FunctionCall<F>,
                    block_id: BlockId<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(CallParams {
                    request: helper.request,
                    block_id: helper.block_id,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_estimateFee` method.
#[derive(Debug, Clone)]
pub struct EstimateFeeParams<F: Default> {
    /// The transaction to estimate
    pub request: Vec<BroadcastedTxn<F>>,
    /// describes what parts of the transaction should be executed
    pub simulation_flags: Vec<SimulationFlagForEstimateFee>,
    /// The hash of the requested block, or number (height) of the requested block, or a block tag, for the block referencing the state or call the transaction on.
    pub block_id: BlockId<F>,
}

impl<F: Copy + Default + Serialize> Serialize for EstimateFeeParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("request", &self.request)?;
        map.serialize_entry("simulation_flags", &self.simulation_flags)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.end()
    }
}

impl<'de, F: Copy + Default + Serialize + Deserialize<'de>> Deserialize<'de>
    for EstimateFeeParams<F>
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Default + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = EstimateFeeParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_estimateFee`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let request: Vec<BroadcastedTxn<F>> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 3 parameters"))?;
                let simulation_flags: Vec<SimulationFlagForEstimateFee> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(2, &"expected 3 parameters"))?;
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(3, &"expected 3 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        4,
                        &"expected 3 parameters",
                    ));
                }

                Ok(EstimateFeeParams {
                    request,
                    simulation_flags,
                    block_id,
                })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F: Default> {
                    request: Vec<BroadcastedTxn<F>>,
                    simulation_flags: Vec<SimulationFlagForEstimateFee>,
                    block_id: BlockId<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(EstimateFeeParams {
                    request: helper.request,
                    simulation_flags: helper.simulation_flags,
                    block_id: helper.block_id,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_estimateMessageFee` method.
#[derive(Debug, Clone)]
pub struct EstimateMessageFeeParams<F> {
    /// the message's parameters
    pub message: MsgFromL1<F>,
    /// The hash of the requested block, or number (height) of the requested block, or a block tag, for the block referencing the state or call the transaction on.
    pub block_id: BlockId<F>,
}

impl<F: Copy + Serialize> Serialize for EstimateMessageFeeParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("message", &self.message)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de> for EstimateMessageFeeParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = EstimateMessageFeeParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_estimateMessageFee`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let message: MsgFromL1<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 2 parameters"))?;
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(2, &"expected 2 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        3,
                        &"expected 2 parameters",
                    ));
                }

                Ok(EstimateMessageFeeParams { message, block_id })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    message: MsgFromL1<F>,
                    block_id: BlockId<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(EstimateMessageFeeParams {
                    message: helper.message,
                    block_id: helper.block_id,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_blockNumber` method.
#[derive(Debug, Clone)]
pub struct BlockNumberParams {}

impl Serialize for BlockNumberParams {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.end()
    }
}

impl<'de> Deserialize<'de> for BlockNumberParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor;

        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BlockNumberParams;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_blockNumber`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        1,
                        &"expected 0 parameters",
                    ));
                }

                Ok(BlockNumberParams {})
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper {}

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(BlockNumberParams {})
            }
        }

        deserializer.deserialize_any(Visitor)
    }
}

/// Parameters of the `starknet_blockHashAndNumber` method.
#[derive(Debug, Clone)]
pub struct BlockHashAndNumberParams {}

impl Serialize for BlockHashAndNumberParams {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.end()
    }
}

impl<'de> Deserialize<'de> for BlockHashAndNumberParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor;

        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BlockHashAndNumberParams;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_blockHashAndNumber`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        1,
                        &"expected 0 parameters",
                    ));
                }

                Ok(BlockHashAndNumberParams {})
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper {}

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(BlockHashAndNumberParams {})
            }
        }

        deserializer.deserialize_any(Visitor)
    }
}

/// Parameters of the `starknet_chainId` method.
#[derive(Debug, Clone)]
pub struct ChainIdParams {}

impl Serialize for ChainIdParams {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.end()
    }
}

impl<'de> Deserialize<'de> for ChainIdParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor;

        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ChainIdParams;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_chainId`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        1,
                        &"expected 0 parameters",
                    ));
                }

                Ok(ChainIdParams {})
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper {}

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(ChainIdParams {})
            }
        }

        deserializer.deserialize_any(Visitor)
    }
}

/// Parameters of the `starknet_syncing` method.
#[derive(Debug, Clone)]
pub struct SyncingParams {}

impl Serialize for SyncingParams {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.end()
    }
}

impl<'de> Deserialize<'de> for SyncingParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor;

        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SyncingParams;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_syncing`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        1,
                        &"expected 0 parameters",
                    ));
                }

                Ok(SyncingParams {})
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper {}

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(SyncingParams {})
            }
        }

        deserializer.deserialize_any(Visitor)
    }
}

/// Parameters of the `starknet_getEvents` method.
#[derive(Debug, Clone)]
pub struct GetEventsParams<F: Copy> {
    /// The conditions used to filter the returned events
    pub filter: EventFilterWithPageRequest<F>,
}

impl<F: Copy + Serialize> Serialize for GetEventsParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("filter", &self.filter)?;
        map.end()
    }
}

impl<'de, F: Copy + Default + Deserialize<'de>> Deserialize<'de> for GetEventsParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Default + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetEventsParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getEvents`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let filter: EventFilterWithPageRequest<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 1 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        2,
                        &"expected 1 parameters",
                    ));
                }

                Ok(GetEventsParams { filter })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F: Copy + Default> {
                    filter: EventFilterWithPageRequest<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetEventsParams {
                    filter: helper.filter,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}

/// Parameters of the `starknet_getNonce` method.
#[derive(Debug, Clone)]
pub struct GetNonceParams<F> {
    /// The hash of the requested block, or number (height) of the requested block, or a block tag
    pub block_id: BlockId<F>,
    /// The address of the contract whose nonce we're seeking
    pub contract_address: Address<F>,
}

impl<F: Copy + Serialize> Serialize for GetNonceParams<F> {
    #[allow(unused_mut)]
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut map = serializer.serialize_map(None)?;
        map.serialize_entry("block_id", &self.block_id)?;
        map.serialize_entry("contract_address", &self.contract_address)?;
        map.end()
    }
}

impl<'de, F: Copy + Serialize + Deserialize<'de>> Deserialize<'de> for GetNonceParams<F> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor<F> {
            marker: PhantomData<F>,
        }

        impl<'de, F: Copy + Serialize + Deserialize<'de>> serde::de::Visitor<'de> for Visitor<F> {
            type Value = GetNonceParams<F>;

            fn expecting(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "the parameters for `starknet_getNonce`")
            }

            #[allow(unused_mut)]
            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::SeqAccess<'de>,
            {
                let block_id: BlockId<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(1, &"expected 2 parameters"))?;
                let contract_address: Address<F> = seq
                    .next_element()?
                    .ok_or_else(|| serde::de::Error::invalid_length(2, &"expected 2 parameters"))?;

                if seq.next_element::<serde::de::IgnoredAny>()?.is_some() {
                    return Err(serde::de::Error::invalid_length(
                        3,
                        &"expected 2 parameters",
                    ));
                }

                Ok(GetNonceParams {
                    block_id,
                    contract_address,
                })
            }

            #[allow(unused_variables)]
            fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[derive(Deserialize)]
                struct Helper<F> {
                    block_id: BlockId<F>,
                    contract_address: Address<F>,
                }

                let helper =
                    Helper::deserialize(serde::de::value::MapAccessDeserializer::new(map))?;

                Ok(GetNonceParams {
                    block_id: helper.block_id,
                    contract_address: helper.contract_address,
                })
            }
        }

        deserializer.deserialize_any(Visitor::<F> {
            marker: PhantomData,
        })
    }
}
